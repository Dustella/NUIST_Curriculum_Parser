import * as cheerio from "cheerio";

interface Lesson {
  name: string;
  position: string;
  teacher: string;
  weeks: number[];
  day: number;
  sections: number[];
}

enum parity {
  odd,
  even,
  both,
}
// a helper function to generate a continuous array
const range = (start: number, end: number, p: parity = parity.both) =>
  Array.from({ length: end - start + 1 }, (_, i) => i + start).filter((i) => {
    if (p === parity.both) return true;
    if (p === parity.odd) return i % 2 === 1;
    if (p === parity.even) return i % 2 === 0;
  });

const mapper = {
  begin: [
    "8:00",
    "8:55",
    "10:10",
    "11:05",
    "13:45",
    "14:40",
    "15:55",
    "16:50",
    "18:45",
    "19:40",
    "20:35",
  ],
  end: [
    "8:45",
    "9:40",
    "10:55",
    "11:50",
    "14:30",
    "15:25",
    "16:40",
    "17:35",
    "19:30",
    "20:25",
    "21:20",
  ],
};

// example text:
// "18周,星期1,08:00-09:40,长望楼206",
// "2-16周(双),星期1,第5节-第6节,信科楼B111",
// "2-10周(双),16周,星期2,第7节-第8节,揽江楼N413"
const parseDetail = (text: string) => {
  const weeks = [];
  const sections = [];
  let day = 0;
  let position = "";

  text.split(",").forEach((param, index) => {
    // if param contains "周", it's the week param
    if (param.includes("周")) {
      // judge if it's a continuous week, odd week contians "单", even week contains "双"
      const p = param.includes("单")
        ? parity.odd
        : param.includes("双")
        ? parity.even
        : parity.both;
      const [start, end] = param.split("周")[0].split("-").map(Number);
      if (end) {
        weeks.push(...range(start, end, p));
      } else {
        weeks.push(start);
      }
    }
    // if param contains "星期", it's the day param
    if (param.includes("星期")) {
      day = Number(param.split("星期")[1]);
    }
    // if param contains "节", it's the section param
    if (param.includes("节")) {
      const [start, end] = param
        .split("-")
        .map((i) => Number(i.replace("第", "").replace("节", "")));
      sections.push(...range(start, end));
    }
    // in some cases, sections are not generated by "节", but by time like "08:00-09:40"
    // use regex to match the time pattern xx:xx-xx:xx
    if (param.match(/\d{2}:\d{2}-\d{2}:\d{2}/)) {
      const [start_time, end_time] = param.split("-");
      // use mapper to get exact section number
      const start = mapper.begin.indexOf(start_time) + 1;
      const end = mapper.end.indexOf(end_time) + 1;
      if (start == end) {
        sections.push(start);
      } else {
        sections.push(...range(start, end));
      }
    }
    // the position is always the last param
    if (index === text.split(",").length - 1) {
      position = param;
    }
  });

  return { weeks, day, position, sections };
};

const merge = (l1: Lesson, l2: Lesson) => {
  // this is a helper function to merge two lessons at a time
  // we will merge l2 into l1
  // for example, if there are two lessons at the same time, the result will be:
  // {
  //   name: "课程1,课程2",
  //   position: "地点1,地点2",
  //   teacher: "老师1,老师2",
  //   weeks: [1],
  //   day: 1,
  //   sections: [1],
  // }
  l1.name += `,${l2.name}`;
  l1.position += `,${l2.position}`;
  l1.teacher += `,${l2.teacher}`;
  return l1;
};

const merger = (raw: Lesson[]): Lesson[] => {
  // in some cases, in one day in a particular week, there are more than one lesson at a time
  // we will scan throgh week 1-20, then scan through day 1-7, then scan through section 1-11
  // to find out if there are more than one lesson at a time
  // if there are, we will merge them into one lesson
  // this function is going to scan through all the lessons and merge them
  const result = new Set<Lesson>([]);
  for (let week = 1; week <= 20; week++) {
    for (let day = 1; day <= 7; day++) {
      for (let section = 1; section <= 11; section += 2) {
        const lessons = raw.filter(
          (i) =>
            i.weeks.includes(week) &&
            i.day === day &&
            i.sections.includes(section)
        );
        if (lessons.length > 1) {
          const merged = lessons.reduce(merge);
          result.add(merged);
        } else if (lessons.length === 1) {
          result.add(lessons[0]);
        }
      }
    }
  }
  return Array.from(result.values());
};

const parser = (instance: cheerio.CheerioAPI): Lesson[] =>
  instance(".mtt_arrange_item")
    .map((number, ele) => {
      const name = instance(ele).find(".mtt_item_kcmc").text().split(" ")[0];
      // const name = instance(ele).find(".mtt_item_kcmc").text();
      const teacher = instance(ele).find(".mtt_item_jxbmc").text();
      const details = instance(ele).find(".mtt_item_room").text();
      const { weeks, day, position, sections } = parseDetail(details);
      return {
        name,
        position,
        teacher,
        weeks,
        day,
        sections,
      };
    })
    .toArray();

async function test() {
  const fs = await import("fs");

  // use sync fs to read text from file content.txt
  const text = fs.readFileSync("./content.txt", "utf8");
  const $ = cheerio.load(text);
  const result = parser($);
  // write result to res.json
  fs.writeFileSync("./res.json", JSON.stringify(result));
  // merge the result
  const merged = merger(result);
  // write merged result to merged.json
  fs.writeFileSync("./merged.json", JSON.stringify(merged));
}

test();
